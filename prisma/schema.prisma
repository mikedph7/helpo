generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  email               String                    @unique
  name                String?
  avatar              String?
  created_at          DateTime                  @default(now())
  updated_at          DateTime                  @updatedAt
  id                  Int                       @id @default(autoincrement())
  email_verified      Boolean                   @default(false)
  password_hash       String?
  phone               String?                   @unique
  phone_verified      Boolean                   @default(false)
  role                Role                      @default(USER)
  bookings            Booking[]
  conversations       ConversationParticipant[]
  favorites           Favorite[]
  message_reactions   MessageReaction[]
  sent_messages       Message[]
  payments            Payment[]
  provider            Provider?
  reviews             Review[]
  sessions            Session[]
  wallet_account      WalletAccount?
  wallet_transactions WalletTransaction[]

  @@map("users")
}

model Session {
  id         String   @id @default(uuid())
  user_id    Int
  token      String   @unique
  expires_at DateTime
  created_at DateTime @default(now())
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@map("sessions")
}

model Provider {
  photo_url       String?
  rating_count    Int?
  verified        Boolean            @default(false)
  bio             String?
  location        String?
  created_at      DateTime           @default(now())
  updated_at      DateTime           @updatedAt
  id              Int                @id @default(autoincrement())
  average_rating  Float?
  name            String
  user_id         Int?               @unique
  bookings        Booking[]
  coverage_cities ProviderCoverage[]
  schedules       ProviderSchedule[]
  user            User?              @relation(fields: [user_id], references: [id])
  services        Service[]
  time_slots      TimeSlot[]

  @@map("providers")
}

model Service {
  name              String
  category          HelpoCategory
  description       String
  price_from        Int?
  tags              String[]
  images            String[]
  what_included     String[]
  requirements      String[]
  pricing_details   Json?
  top_rated         Boolean           @default(false)
  verified          Boolean           @default(false)
  next_availability DateTime?
  created_at        DateTime          @default(now())
  updated_at        DateTime          @updatedAt
  id                Int               @id @default(autoincrement())
  provider_id       Int?
  duration_minutes  Int?
  auto_confirm      Boolean           @default(false)
  bookings          Booking[]
  favorites         Favorite[]
  reviews           Review[]
  coverage_cities   ServiceCoverage[]
  provider          Provider?         @relation(fields: [provider_id], references: [id])

  @@map("services")
}

model Booking {
  scheduled_at          DateTime
  location              String?
  status                BookingStatus  @default(pending)
  total_price           Int
  notes                 String?
  number_of_people      Int?
  payment_method_id     String?
  created_at            DateTime       @default(now())
  updated_at            DateTime       @updatedAt
  id                    Int            @id @default(autoincrement())
  user_id               Int
  service_id            Int
  provider_id           Int
  canceled_at           DateTime?
  cancellation_details  String?
  cancellation_reason   String?
  payment_status        PaymentStatus  @default(unpaid)
  provider_confirmed_at DateTime?
  provider              Provider       @relation(fields: [provider_id], references: [id])
  service               Service        @relation(fields: [service_id], references: [id])
  user                  User           @relation(fields: [user_id], references: [id])
  conversations         Conversation[]
  payments              Payment[]
  review                Review?
  time_slots            TimeSlot[]

  @@map("bookings")
}

model Review {
  rating     Int
  comment    String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  id         Int      @id @default(autoincrement())
  user_id    Int?
  service_id Int
  avatar_url String?
  name       String
  booking_id Int?     @unique
  booking    Booking? @relation(fields: [booking_id], references: [id])
  service    Service  @relation(fields: [service_id], references: [id])
  user       User?    @relation(fields: [user_id], references: [id])

  @@map("reviews")
}

model Favorite {
  created_at DateTime @default(now())
  id         Int      @id @default(autoincrement())
  user_id    Int
  service_id Int
  service    Service  @relation(fields: [service_id], references: [id])
  user       User     @relation(fields: [user_id], references: [id])

  @@unique([user_id, service_id])
  @@map("favorites")
}

model SearchLog {
  query         String?
  category      String?
  location      String?
  results_count Int
  user_clicked  Boolean  @default(false)
  created_at    DateTime @default(now())
  id            Int      @id @default(autoincrement())

  @@map("search_logs")
}

model City {
  id                Int                @id @default(autoincrement())
  name              String             @unique
  region            String
  province          String?
  created_at        DateTime           @default(now())
  updated_at        DateTime           @updatedAt
  areas             Area[]
  provider_coverage ProviderCoverage[]
  service_coverage  ServiceCoverage[]

  @@map("cities")
}

model Area {
  id         Int      @id @default(autoincrement())
  name       String   @unique
  city_id    Int
  aliases    String[]
  is_active  Boolean  @default(true)
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
  city       City     @relation(fields: [city_id], references: [id], onDelete: Cascade)

  @@map("areas")
}

model ProviderCoverage {
  id          Int      @id @default(autoincrement())
  provider_id Int
  city_id     Int
  created_at  DateTime @default(now())
  city        City     @relation(fields: [city_id], references: [id], onDelete: Cascade)
  provider    Provider @relation(fields: [provider_id], references: [id], onDelete: Cascade)

  @@unique([provider_id, city_id])
  @@map("provider_coverage")
}

model ServiceCoverage {
  id         Int      @id @default(autoincrement())
  service_id Int
  city_id    Int
  created_at DateTime @default(now())
  city       City     @relation(fields: [city_id], references: [id], onDelete: Cascade)
  service    Service  @relation(fields: [service_id], references: [id], onDelete: Cascade)

  @@unique([service_id, city_id])
  @@map("service_coverage")
}

model ProviderSchedule {
  id           Int      @id @default(autoincrement())
  provider_id  Int
  day_of_week  Int
  start_time   String
  end_time     String
  is_available Boolean  @default(true)
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
  provider     Provider @relation(fields: [provider_id], references: [id], onDelete: Cascade)

  @@unique([provider_id, day_of_week])
  @@map("provider_schedules")
}

model TimeSlot {
  id           Int      @id @default(autoincrement())
  provider_id  Int
  date         DateTime @db.Date
  start_time   String
  end_time     String
  is_available Boolean  @default(true)
  is_booked    Boolean  @default(false)
  booking_id   Int?
  created_at   DateTime @default(now())
  updated_at   DateTime @updatedAt
  booking      Booking? @relation(fields: [booking_id], references: [id])
  provider     Provider @relation(fields: [provider_id], references: [id], onDelete: Cascade)

  @@unique([provider_id, date, start_time])
  @@index([provider_id, date])
  @@index([date, is_available])
  @@map("time_slots")
}

model Conversation {
  id              Int                       @id @default(autoincrement())
  type            ConversationType          @default(DIRECT)
  title           String?
  booking_id      Int?
  last_message_at DateTime                  @default(now())
  created_at      DateTime                  @default(now())
  updated_at      DateTime                  @updatedAt
  participants    ConversationParticipant[]
  booking         Booking?                  @relation(fields: [booking_id], references: [id])
  messages        Message[]

  @@index([booking_id])
  @@index([last_message_at])
  @@map("conversations")
}

model ConversationParticipant {
  id              Int             @id @default(autoincrement())
  conversation_id Int
  user_id         Int
  role            ParticipantRole @default(MEMBER)
  joined_at       DateTime        @default(now())
  last_read_at    DateTime?
  is_muted        Boolean         @default(false)
  is_archived     Boolean         @default(false)
  conversation    Conversation    @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  user            User            @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([conversation_id, user_id])
  @@index([user_id])
  @@map("conversation_participants")
}

model Message {
  id              Int                 @id @default(autoincrement())
  conversation_id Int
  sender_id       Int
  content         String?
  message_type    MessageType         @default(TEXT)
  reply_to_id     Int?
  edited_at       DateTime?
  deleted_at      DateTime?
  created_at      DateTime            @default(now())
  updated_at      DateTime            @updatedAt
  metadata        Json?
  attachments     MessageAttachment[]
  reactions       MessageReaction[]
  conversation    Conversation        @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  reply_to        Message?            @relation("MessageReplies", fields: [reply_to_id], references: [id])
  replies         Message[]           @relation("MessageReplies")
  sender          User                @relation(fields: [sender_id], references: [id], onDelete: Cascade)

  @@index([conversation_id, created_at])
  @@index([sender_id])
  @@index([reply_to_id])
  @@map("messages")
}

model MessageAttachment {
  id         Int      @id @default(autoincrement())
  message_id Int
  filename   String
  file_url   String
  file_type  String
  file_size  Int
  created_at DateTime @default(now())
  message    Message  @relation(fields: [message_id], references: [id], onDelete: Cascade)

  @@index([message_id])
  @@map("message_attachments")
}

model MessageReaction {
  id         Int      @id @default(autoincrement())
  message_id Int
  user_id    Int
  emoji      String
  created_at DateTime @default(now())
  message    Message  @relation(fields: [message_id], references: [id], onDelete: Cascade)
  user       User     @relation(fields: [user_id], references: [id], onDelete: Cascade)

  @@unique([message_id, user_id, emoji])
  @@index([message_id])
  @@map("message_reactions")
}

model Payment {
  id                    Int                @id @default(autoincrement())
  amount                Int
  payment_method        PaymentMethodType
  payment_type          PaymentType
  status                PaymentStatus      @default(pending)
  reference_number      String?
  proof_image_url       String?
  admin_notes           String?
  verified_by           Int?
  verified_at           DateTime?
  created_at            DateTime           @default(now())
  updated_at            DateTime           @updatedAt
  user_id               Int
  booking_id            Int?
  wallet_transaction_id Int?
  booking               Booking?           @relation(fields: [booking_id], references: [id])
  user                  User               @relation(fields: [user_id], references: [id])
  wallet_transaction    WalletTransaction? @relation(fields: [wallet_transaction_id], references: [id])

  @@map("payments")
}

model WalletTransaction {
  id               Int                   @id @default(autoincrement())
  amount           Int
  transaction_type WalletTransactionType
  description      String
  reference_id     String?
  balance_before   Int
  balance_after    Int
  created_at       DateTime              @default(now())
  user_id          Int
  payments         Payment[]
  user             User                  @relation(fields: [user_id], references: [id])

  @@map("wallet_transactions")
}

model PaymentMethod {
  id             Int      @id @default(autoincrement())
  method_type    String
  name           String
  account_number String?
  account_name   String?
  qr_code_url    String?
  instructions   String?
  is_active      Boolean  @default(true)
  created_at     DateTime @default(now())
  updated_at     DateTime @updatedAt

  @@map("payment_methods")
}

model WalletAccount {
  id              String        @id @default(cuid())
  user_id         Int?          @unique
  account_type    AccountType   @default(USER)
  available_cents Int           @default(0)
  pending_cents   Int           @default(0)
  version         Int           @default(0)
  created_at      DateTime      @default(now())
  updated_at      DateTime      @updatedAt
  entries_from    LedgerEntry[] @relation("FromAccount")
  entries_to      LedgerEntry[] @relation("ToAccount")
  user            User?         @relation(fields: [user_id], references: [id])

  @@map("wallet_accounts")
}

model LedgerEntry {
  id              String        @id @default(cuid())
  transfer_id     String
  from_account_id String
  to_account_id   String
  amount_cents    Int
  state           EntryState    @default(pending)
  occurred_at     DateTime      @default(now())
  memo            String?
  idempotency_key String        @unique
  reference_type  String?
  reference_id    String?
  created_at      DateTime      @default(now())
  from_account    WalletAccount @relation("FromAccount", fields: [from_account_id], references: [id])
  to_account      WalletAccount @relation("ToAccount", fields: [to_account_id], references: [id])

  @@index([transfer_id])
  @@index([from_account_id])
  @@index([to_account_id])
  @@index([state])
  @@index([occurred_at])
  @@map("ledger_entries")
}

model WalletSnapshot {
  id            String   @id @default(cuid())
  account_id    String
  balance_cents Int
  pending_cents Int
  snapshot_date DateTime
  entry_count   Int
  created_at    DateTime @default(now())

  @@unique([account_id, snapshot_date])
  @@index([snapshot_date])
  @@map("wallet_snapshots")
}

enum Role {
  USER
  PROVIDER
  ADMIN
}

enum HelpoCategory {
  Cleaning
  Repair
  Pets
  Lessons
}

enum BookingStatus {
  pending
  confirmed
  completed
  canceled
}

enum PaymentStatus {
  unpaid
  pending
  paid
  failed
  refunded
}

enum PaymentMethodType {
  wallet
  gcash
  bank_transfer
  credit_card
  paypal
}

enum PaymentType {
  booking
  wallet_reload
  refund
}

enum WalletTransactionType {
  reload
  payment
  refund
  admin_adjustment
}

enum ConversationType {
  DIRECT
  GROUP
  SUPPORT
}

enum ParticipantRole {
  ADMIN
  MODERATOR
  MEMBER
}

enum MessageType {
  TEXT
  IMAGE
  FILE
  SYSTEM
  BOOKING_REQUEST
  BOOKING_UPDATE
}

enum AccountType {
  USER
  PLATFORM
  ESCROW
}

enum EntryState {
  pending
  posted
  reversed
}
